
laravel.com
Testing: Getting Started - Laravel 12.x - The PHP Framework For Web Artisans
9–11 minutes
Testing: Getting Started

    Introduction
    Environment
    Creating Tests
    Running Tests
        Running Tests in Parallel
        Reporting Test Coverage
        Profiling Tests
    Configuration Caching

Introduction

Laravel is built with testing in mind. In fact, support for testing with Pest and PHPUnit is included out of the box and a phpunit.xml file is already set up for your application. The framework also ships with convenient helper methods that allow you to expressively test your applications.

By default, your application's tests directory contains two directories: Feature and Unit. Unit tests are tests that focus on a very small, isolated portion of your code. In fact, most unit tests probably focus on a single method. Tests within your "Unit" test directory do not boot your Laravel application and therefore are unable to access your application's database or other framework services.

Feature tests may test a larger portion of your code, including how several objects interact with each other or even a full HTTP request to a JSON endpoint. Generally, most of your tests should be feature tests. These types of tests provide the most confidence that your system as a whole is functioning as intended.

An ExampleTest.php file is provided in both the Feature and Unit test directories. After installing a new Laravel application, execute the vendor/bin/pest, vendor/bin/phpunit, or php artisan test commands to run your tests.
Environment

When running tests, Laravel will automatically set the configuration environment to testing because of the environment variables defined in the phpunit.xml file. Laravel also automatically configures the session and cache to the array driver so that no session or cache data will be persisted while testing.

You are free to define other testing environment configuration values as necessary. The testing environment variables may be configured in your application's phpunit.xml file, but make sure to clear your configuration cache using the config:clear Artisan command before running your tests!
The .env.testing Environment File

In addition, you may create a .env.testing file in the root of your project. This file will be used instead of the .env file when running Pest and PHPUnit tests or executing Artisan commands with the --env=testing option.
Creating Tests

To create a new test case, use the make:test Artisan command. By default, tests will be placed in the tests/Feature directory:

1php artisan make:test UserTest

If you would like to create a test within the tests/Unit directory, you may use the --unit option when executing the make:test command:

1php artisan make:test UserTest --unit

Test stubs may be customized using stub publishing.

Once the test has been generated, you may define test as you normally would using Pest or PHPUnit. To run your tests, execute the vendor/bin/pest, vendor/bin/phpunit, or php artisan test command from your terminal:

1<?php

2 

3test('basic', function () {

4    expect(true)->toBeTrue();

5});

 1<?php

 2 

 3namespace Tests\Unit;

 4 

 5use PHPUnit\Framework\TestCase;

 6 

 7class ExampleTest extends TestCase

 8{

 9    /**

10     * A basic test example.

11     */

12    public function test_basic_test(): void

13    {

14        $this->assertTrue(true);

15    }

16}

If you define your own setUp / tearDown methods within a test class, be sure to call the respective parent::setUp() / parent::tearDown() methods on the parent class. Typically, you should invoke parent::setUp() at the start of your own setUp method, and parent::tearDown() at the end of your tearDown method.
Running Tests

As mentioned previously, once you've written tests, you may run them using pest or phpunit:

1./vendor/bin/pest

1./vendor/bin/phpunit

In addition to the pest or phpunit commands, you may use the test Artisan command to run your tests. The Artisan test runner provides verbose test reports in order to ease development and debugging:

1php artisan test

Any arguments that can be passed to the pest or phpunit commands may also be passed to the Artisan test command:

1php artisan test --testsuite=Feature --stop-on-failure

Running Tests in Parallel

By default, Laravel and Pest / PHPUnit execute your tests sequentially within a single process. However, you may greatly reduce the amount of time it takes to run your tests by running tests simultaneously across multiple processes. To get started, you should install the brianium/paratest Composer package as a "dev" dependency. Then, include the --parallel option when executing the test Artisan command:

1composer require brianium/paratest --dev

2 

3php artisan test --parallel

By default, Laravel will create as many processes as there are available CPU cores on your machine. However, you may adjust the number of processes using the --processes option:

1php artisan test --parallel --processes=4

When running tests in parallel, some Pest / PHPUnit options (such as --do-not-cache-result) may not be available.
Parallel Testing and Databases

As long as you have configured a primary database connection, Laravel automatically handles creating and migrating a test database for each parallel process that is running your tests. The test databases will be suffixed with a process token which is unique per process. For example, if you have two parallel test processes, Laravel will create and use your_db_test_1 and your_db_test_2 test databases.

By default, test databases persist between calls to the test Artisan command so that they can be used again by subsequent test invocations. However, you may re-create them using the --recreate-databases option:

1php artisan test --parallel --recreate-databases

Parallel Testing Hooks

Occasionally, you may need to prepare certain resources used by your application's tests so they may be safely used by multiple test processes.

Using the ParallelTesting facade, you may specify code to be executed on the setUp and tearDown of a process or test case. The given closures receive the $token and $testCase variables that contain the process token and the current test case, respectively:

 1<?php

 2 

 3namespace App\Providers;

 4 

 5use Illuminate\Support\Facades\Artisan;

 6use Illuminate\Support\Facades\ParallelTesting;

 7use Illuminate\Support\ServiceProvider;

 8use PHPUnit\Framework\TestCase;

 9 

10class AppServiceProvider extends ServiceProvider

11{

12    /**

13     * Bootstrap any application services.

14     */

15    public function boot(): void

16    {

17        ParallelTesting::setUpProcess(function (int $token) {

18            // ...

19        });

20 

21        ParallelTesting::setUpTestCase(function (int $token, TestCase $testCase) {

22            // ...

23        });

24 

25        // Executed when a test database is created...

26        ParallelTesting::setUpTestDatabase(function (string $database, int $token) {

27            Artisan::call('db:seed');

28        });

29 

30        ParallelTesting::tearDownTestCase(function (int $token, TestCase $testCase) {

31            // ...

32        });

33 

34        ParallelTesting::tearDownProcess(function (int $token) {

35            // ...

36        });

37    }

38}

Accessing the Parallel Testing Token

If you would like to access the current parallel process "token" from any other location in your application's test code, you may use the token method. This token is a unique, string identifier for an individual test process and may be used to segment resources across parallel test processes. For example, Laravel automatically appends this token to the end of the test databases created by each parallel testing process:

1$token = ParallelTesting::token();

Reporting Test Coverage

This feature requires Xdebug or PCOV.

When running your application tests, you may want to determine whether your test cases are actually covering the application code and how much application code is used when running your tests. To accomplish this, you may provide the --coverage option when invoking the test command:

1php artisan test --coverage

Enforcing a Minimum Coverage Threshold

You may use the --min option to define a minimum test coverage threshold for your application. The test suite will fail if this threshold is not met:

1php artisan test --coverage --min=80.3

Profiling Tests

The Artisan test runner also includes a convenient mechanism for listing your application's slowest tests. Invoke the test command with the --profile option to be presented with a list of your ten slowest tests, allowing you to easily investigate which tests can be improved to speed up your test suite:

1php artisan test --profile

Configuration Caching

When running tests, Laravel boots the application for each individual test method. Without a cached configuration file, each configuration file in your application must be loaded at the start of a test. To build the configuration once and re-use it for all tests in a single run, you may use the Illuminate\Foundation\Testing\WithCachedConfig trait:

1<?php

2 

3use Illuminate\Foundation\Testing\WithCachedConfig;

4 

5pest()->use(WithCachedConfig::class);

6 

7// ...

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Illuminate\Foundation\Testing\WithCachedConfig;

 6use Tests\TestCase;

 7 

 8class ConfigTest extends TestCase

 9{

10    use WithCachedConfig;

11 

12    // ...

13}


laravel.com
HTTP Tests - Laravel 12.x - The PHP Framework For Web Artisans
assertUnauthorized
43–55 minutes

    Introduction
    Making Requests
        Customizing Request Headers
        Cookies
        Session / Authentication
        Debugging Responses
        Exception Handling
    Testing JSON APIs
        Fluent JSON Testing
    Testing File Uploads
    Testing Views
        Rendering Blade and Components
    Caching Routes
    Available Assertions
        Response Assertions
        Authentication Assertions
        Validation Assertions

Introduction

Laravel provides a very fluent API for making HTTP requests to your application and examining the responses. For example, take a look at the feature test defined below:

1<?php

2 

3test('the application returns a successful response', function () {

4    $response = $this->get('/');

5 

6    $response->assertStatus(200);

7});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Tests\TestCase;

 6 

 7class ExampleTest extends TestCase

 8{

 9    /**

10     * A basic test example.

11     */

12    public function test_the_application_returns_a_successful_response(): void

13    {

14        $response = $this->get('/');

15 

16        $response->assertStatus(200);

17    }

18}

The get method makes a GET request into the application, while the assertStatus method asserts that the returned response should have the given HTTP status code. In addition to this simple assertion, Laravel also contains a variety of assertions for inspecting the response headers, content, JSON structure, and more.
Making Requests

To make a request to your application, you may invoke the get, post, put, patch, or delete methods within your test. These methods do not actually issue a "real" HTTP request to your application. Instead, the entire network request is simulated internally.

Instead of returning an Illuminate\Http\Response instance, test request methods return an instance of Illuminate\Testing\TestResponse, which provides a variety of helpful assertions that allow you to inspect your application's responses:

1<?php

2 

3test('basic request', function () {

4    $response = $this->get('/');

5 

6    $response->assertStatus(200);

7});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Tests\TestCase;

 6 

 7class ExampleTest extends TestCase

 8{

 9    /**

10     * A basic test example.

11     */

12    public function test_a_basic_request(): void

13    {

14        $response = $this->get('/');

15 

16        $response->assertStatus(200);

17    }

18}

In general, each of your tests should only make one request to your application. Unexpected behavior may occur if multiple requests are executed within a single test method.

For convenience, the CSRF middleware is automatically disabled when running tests.

You may use the withHeaders method to customize the request's headers before it is sent to the application. This method allows you to add any custom headers you would like to the request:

1<?php

2 

3test('interacting with headers', function () {

4    $response = $this->withHeaders([

5        'X-Header' => 'Value',

6    ])->post('/user', ['name' => 'Sally']);

7 

8    $response->assertStatus(201);

9});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Tests\TestCase;

 6 

 7class ExampleTest extends TestCase

 8{

 9    /**

10     * A basic functional test example.

11     */

12    public function test_interacting_with_headers(): void

13    {

14        $response = $this->withHeaders([

15            'X-Header' => 'Value',

16        ])->post('/user', ['name' => 'Sally']);

17 

18        $response->assertStatus(201);

19    }

20}

Cookies

You may use the withCookie or withCookies methods to set cookie values before making a request. The withCookie method accepts a cookie name and value as its two arguments, while the withCookies method accepts an array of name / value pairs:

 1<?php

 2 

 3test('interacting with cookies', function () {

 4    $response = $this->withCookie('color', 'blue')->get('/');

 5 

 6    $response = $this->withCookies([

 7        'color' => 'blue',

 8        'name' => 'Taylor',

 9    ])->get('/');

10 

11    //

12});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Tests\TestCase;

 6 

 7class ExampleTest extends TestCase

 8{

 9    public function test_interacting_with_cookies(): void

10    {

11        $response = $this->withCookie('color', 'blue')->get('/');

12 

13        $response = $this->withCookies([

14            'color' => 'blue',

15            'name' => 'Taylor',

16        ])->get('/');

17 

18        //

19    }

20}

Session / Authentication

Laravel provides several helpers for interacting with the session during HTTP testing. First, you may set the session data to a given array using the withSession method. This is useful for loading the session with data before issuing a request to your application:

1<?php

2 

3test('interacting with the session', function () {

4    $response = $this->withSession(['banned' => false])->get('/');

5 

6    //

7});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Tests\TestCase;

 6 

 7class ExampleTest extends TestCase

 8{

 9    public function test_interacting_with_the_session(): void

10    {

11        $response = $this->withSession(['banned' => false])->get('/');

12 

13        //

14    }

15}

Laravel's session is typically used to maintain state for the currently authenticated user. Therefore, the actingAs helper method provides a simple way to authenticate a given user as the current user. For example, we may use a model factory to generate and authenticate a user:

 1<?php

 2 

 3use App\Models\User;

 4 

 5test('an action that requires authentication', function () {

 6    $user = User::factory()->create();

 7 

 8    $response = $this->actingAs($user)

 9        ->withSession(['banned' => false])

10        ->get('/');

11 

12    //

13});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use App\Models\User;

 6use Tests\TestCase;

 7 

 8class ExampleTest extends TestCase

 9{

10    public function test_an_action_that_requires_authentication(): void

11    {

12        $user = User::factory()->create();

13 

14        $response = $this->actingAs($user)

15            ->withSession(['banned' => false])

16            ->get('/');

17 

18        //

19    }

20}

You may also specify which guard should be used to authenticate the given user by passing the guard name as the second argument to the actingAs method. The guard that is provided to the actingAs method will also become the default guard for the duration of the test:

1$this->actingAs($user, 'web');

If you would like to ensure the request is unauthenticated, you may use the actingAsGuest method:

1$this->actingAsGuest();

Debugging Responses

After making a test request to your application, the dump, dumpHeaders, and dumpSession methods may be used to examine and debug the response contents:

1<?php

2 

3test('basic test', function () {

4    $response = $this->get('/');

5 

6    $response->dump();

7    $response->dumpHeaders();

8    $response->dumpSession();

9});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Tests\TestCase;

 6 

 7class ExampleTest extends TestCase

 8{

 9    /**

10     * A basic test example.

11     */

12    public function test_basic_test(): void

13    {

14        $response = $this->get('/');

15 

16        $response->dump();

17        $response->dumpHeaders();

18        $response->dumpSession();

19    }

20}

Alternatively, you may use the dd, ddHeaders, ddBody, ddJson, and ddSession methods to dump information about the response and then stop execution:

 1<?php

 2 

 3test('basic test', function () {

 4    $response = $this->get('/');

 5 

 6    $response->dd();

 7    $response->ddHeaders();

 8    $response->ddBody();

 9    $response->ddJson();

10    $response->ddSession();

11});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Tests\TestCase;

 6 

 7class ExampleTest extends TestCase

 8{

 9    /**

10     * A basic test example.

11     */

12    public function test_basic_test(): void

13    {

14        $response = $this->get('/');

15 

16        $response->dd();

17        $response->ddHeaders();

18        $response->ddBody();

19        $response->ddJson();

20        $response->ddSession();

21    }

22}

Exception Handling

Sometimes you may need to test that your application is throwing a specific exception. To accomplish this, you may "fake" the exception handler via the Exceptions facade. Once the exception handler has been faked, you may utilize the assertReported and assertNotReported methods to make assertions against exceptions that were thrown during the request:

 1<?php

 2 

 3use App\Exceptions\InvalidOrderException;

 4use Illuminate\Support\Facades\Exceptions;

 5 

 6test('exception is thrown', function () {

 7    Exceptions::fake();

 8 

 9    $response = $this->get('/order/1');

10 

11    // Assert an exception was thrown...

12    Exceptions::assertReported(InvalidOrderException::class);

13 

14    // Assert against the exception...

15    Exceptions::assertReported(function (InvalidOrderException $e) {

16        return $e->getMessage() === 'The order was invalid.';

17    });

18});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use App\Exceptions\InvalidOrderException;

 6use Illuminate\Support\Facades\Exceptions;

 7use Tests\TestCase;

 8 

 9class ExampleTest extends TestCase

10{

11    /**

12     * A basic test example.

13     */

14    public function test_exception_is_thrown(): void

15    {

16        Exceptions::fake();

17 

18        $response = $this->get('/');

19 

20        // Assert an exception was thrown...

21        Exceptions::assertReported(InvalidOrderException::class);

22 

23        // Assert against the exception...

24        Exceptions::assertReported(function (InvalidOrderException $e) {

25            return $e->getMessage() === 'The order was invalid.';

26        });

27    }

28}

The assertNotReported and assertNothingReported methods may be used to assert that a given exception was not thrown during the request or that no exceptions were thrown:

1Exceptions::assertNotReported(InvalidOrderException::class);

2 

3Exceptions::assertNothingReported();

You may totally disable exception handling for a given request by invoking the withoutExceptionHandling method before making your request:

1$response = $this->withoutExceptionHandling()->get('/');

In addition, if you would like to ensure that your application is not utilizing features that have been deprecated by the PHP language or the libraries your application is using, you may invoke the withoutDeprecationHandling method before making your request. When deprecation handling is disabled, deprecation warnings will be converted to exceptions, thus causing your test to fail:

1$response = $this->withoutDeprecationHandling()->get('/');

The assertThrows method may be used to assert that code within a given closure throws an exception of the specified type:

1$this->assertThrows(

2    fn () => (new ProcessOrder)->execute(),

3    OrderInvalid::class

4);

If you would like to inspect and make assertions against the exception that is thrown, you may provide a closure as the second argument to the assertThrows method:

1$this->assertThrows(

2    fn () => (new ProcessOrder)->execute(),

3    fn (OrderInvalid $e) => $e->orderId() === 123;

4);

The assertDoesntThrow method may be used to assert that the code within a given closure does not throw any exceptions:

1$this->assertDoesntThrow(fn () => (new ProcessOrder)->execute());

Testing JSON APIs

Laravel also provides several helpers for testing JSON APIs and their responses. For example, the json, getJson, postJson, putJson, patchJson, deleteJson, and optionsJson methods may be used to issue JSON requests with various HTTP verbs. You may also easily pass data and headers to these methods. To get started, let's write a test to make a POST request to /api/user and assert that the expected JSON data was returned:

 1<?php

 2 

 3test('making an api request', function () {

 4    $response = $this->postJson('/api/user', ['name' => 'Sally']);

 5 

 6    $response

 7        ->assertStatus(201)

 8        ->assertJson([

 9            'created' => true,

10        ]);

11});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Tests\TestCase;

 6 

 7class ExampleTest extends TestCase

 8{

 9    /**

10     * A basic functional test example.

11     */

12    public function test_making_an_api_request(): void

13    {

14        $response = $this->postJson('/api/user', ['name' => 'Sally']);

15 

16        $response

17            ->assertStatus(201)

18            ->assertJson([

19                'created' => true,

20            ]);

21    }

22}

In addition, JSON response data may be accessed as array variables on the response, making it convenient for you to inspect the individual values returned within a JSON response:

1expect($response['created'])->toBeTrue();

1$this->assertTrue($response['created']);

The assertJson method converts the response to an array to verify that the given array exists within the JSON response returned by the application. So, if there are other properties in the JSON response, this test will still pass as long as the given fragment is present.
Asserting Exact JSON Matches

As previously mentioned, the assertJson method may be used to assert that a fragment of JSON exists within the JSON response. If you would like to verify that a given array exactly matches the JSON returned by your application, you should use the assertExactJson method:

 1<?php

 2 

 3test('asserting an exact json match', function () {

 4    $response = $this->postJson('/user', ['name' => 'Sally']);

 5 

 6    $response

 7        ->assertStatus(201)

 8        ->assertExactJson([

 9            'created' => true,

10        ]);

11});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Tests\TestCase;

 6 

 7class ExampleTest extends TestCase

 8{

 9    /**

10     * A basic functional test example.

11     */

12    public function test_asserting_an_exact_json_match(): void

13    {

14        $response = $this->postJson('/user', ['name' => 'Sally']);

15 

16        $response

17            ->assertStatus(201)

18            ->assertExactJson([

19                'created' => true,

20            ]);

21    }

22}

Asserting on JSON Paths

If you would like to verify that the JSON response contains the given data at a specified path, you should use the assertJsonPath method:

1<?php

2 

3test('asserting a json path value', function () {

4    $response = $this->postJson('/user', ['name' => 'Sally']);

5 

6    $response

7        ->assertStatus(201)

8        ->assertJsonPath('team.owner.name', 'Darian');

9});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Tests\TestCase;

 6 

 7class ExampleTest extends TestCase

 8{

 9    /**

10     * A basic functional test example.

11     */

12    public function test_asserting_a_json_paths_value(): void

13    {

14        $response = $this->postJson('/user', ['name' => 'Sally']);

15 

16        $response

17            ->assertStatus(201)

18            ->assertJsonPath('team.owner.name', 'Darian');

19    }

20}

The assertJsonPath method also accepts a closure, which may be used to dynamically determine if the assertion should pass:

1$response->assertJsonPath('team.owner.name', fn (string $name) => strlen($name) >= 3);

Fluent JSON Testing

Laravel also offers a beautiful way to fluently test your application's JSON responses. To get started, pass a closure to the assertJson method. This closure will be invoked with an instance of Illuminate\Testing\Fluent\AssertableJson which can be used to make assertions against the JSON that was returned by your application. The where method may be used to make assertions against a particular attribute of the JSON, while the missing method may be used to assert that a particular attribute is missing from the JSON:

 1use Illuminate\Testing\Fluent\AssertableJson;

 2 

 3test('fluent json', function () {

 4    $response = $this->getJson('/users/1');

 5 

 6    $response

 7        ->assertJson(fn (AssertableJson $json) =>

 8            $json->where('id', 1)

 9                ->where('name', 'Victoria Faith')

10                ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))

11                ->whereNot('status', 'pending')

12                ->missing('password')

13                ->etc()

14        );

15});

 1use Illuminate\Testing\Fluent\AssertableJson;

 2 

 3/**

 4 * A basic functional test example.

 5 */

 6public function test_fluent_json(): void

 7{

 8    $response = $this->getJson('/users/1');

 9 

10    $response

11        ->assertJson(fn (AssertableJson $json) =>

12            $json->where('id', 1)

13                ->where('name', 'Victoria Faith')

14                ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))

15                ->whereNot('status', 'pending')

16                ->missing('password')

17                ->etc()

18        );

19}

Understanding the etc Method

In the example above, you may have noticed we invoked the etc method at the end of our assertion chain. This method informs Laravel that there may be other attributes present on the JSON object. If the etc method is not used, the test will fail if other attributes that you did not make assertions against exist on the JSON object.

The intention behind this behavior is to protect you from unintentionally exposing sensitive information in your JSON responses by forcing you to either explicitly make an assertion against the attribute or explicitly allow additional attributes via the etc method.

However, you should be aware that not including the etc method in your assertion chain does not ensure that additional attributes are not being added to arrays that are nested within your JSON object. The etc method only ensures that no additional attributes exist at the nesting level in which the etc method is invoked.
Asserting Attribute Presence / Absence

To assert that an attribute is present or absent, you may use the has and missing methods:

1$response->assertJson(fn (AssertableJson $json) =>

2    $json->has('data')

3        ->missing('message')

4);

In addition, the hasAll and missingAll methods allow asserting the presence or absence of multiple attributes simultaneously:

1$response->assertJson(fn (AssertableJson $json) =>

2    $json->hasAll(['status', 'data'])

3        ->missingAll(['message', 'code'])

4);

You may use the hasAny method to determine if at least one of a given list of attributes is present:

1$response->assertJson(fn (AssertableJson $json) =>

2    $json->has('status')

3        ->hasAny('data', 'message', 'code')

4);

Asserting Against JSON Collections

Often, your route will return a JSON response that contains multiple items, such as multiple users:

1Route::get('/users', function () {

2    return User::all();

3});

In these situations, we may use the fluent JSON object's has method to make assertions against the users included in the response. For example, let's assert that the JSON response contains three users. Next, we'll make some assertions about the first user in the collection using the first method. The first method accepts a closure which receives another assertable JSON string that we can use to make assertions about the first object in the JSON collection:

 1$response

 2    ->assertJson(fn (AssertableJson $json) =>

 3        $json->has(3)

 4            ->first(fn (AssertableJson $json) =>

 5                $json->where('id', 1)

 6                    ->where('name', 'Victoria Faith')

 7                    ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))

 8                    ->missing('password')

 9                    ->etc()

10            )

11    );

Scoping JSON Collection Assertions

Sometimes, your application's routes will return JSON collections that are assigned named keys:

1Route::get('/users', function () {

2    return [

3        'meta' => [...],

4        'users' => User::all(),

5    ];

6})

When testing these routes, you may use the has method to assert against the number of items in the collection. In addition, you may use the has method to scope a chain of assertions:

 1$response

 2    ->assertJson(fn (AssertableJson $json) =>

 3        $json->has('meta')

 4            ->has('users', 3)

 5            ->has('users.0', fn (AssertableJson $json) =>

 6                $json->where('id', 1)

 7                    ->where('name', 'Victoria Faith')

 8                    ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))

 9                    ->missing('password')

10                    ->etc()

11            )

12    );

However, instead of making two separate calls to the has method to assert against the users collection, you may make a single call which provides a closure as its third parameter. When doing so, the closure will automatically be invoked and scoped to the first item in the collection:

 1$response

 2    ->assertJson(fn (AssertableJson $json) =>

 3        $json->has('meta')

 4            ->has('users', 3, fn (AssertableJson $json) =>

 5                $json->where('id', 1)

 6                    ->where('name', 'Victoria Faith')

 7                    ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))

 8                    ->missing('password')

 9                    ->etc()

10            )

11    );

Asserting JSON Types

You may only want to assert that the properties in the JSON response are of a certain type. The Illuminate\Testing\Fluent\AssertableJson class provides the whereType and whereAllType methods for doing just that:

1$response->assertJson(fn (AssertableJson $json) =>

2    $json->whereType('id', 'integer')

3        ->whereAllType([

4            'users.0.name' => 'string',

5            'meta' => 'array'

6        ])

7);

You may specify multiple types using the | character, or passing an array of types as the second parameter to the whereType method. The assertion will be successful if the response value is any of the listed types:

1$response->assertJson(fn (AssertableJson $json) =>

2    $json->whereType('name', 'string|null')

3        ->whereType('id', ['string', 'integer'])

4);

The whereType and whereAllType methods recognize the following types: string, integer, double, boolean, array, and null.
Testing File Uploads

The Illuminate\Http\UploadedFile class provides a fake method which may be used to generate dummy files or images for testing. This, combined with the Storage facade's fake method, greatly simplifies the testing of file uploads. For example, you may combine these two features to easily test an avatar upload form:

 1<?php

 2 

 3use Illuminate\Http\UploadedFile;

 4use Illuminate\Support\Facades\Storage;

 5 

 6test('avatars can be uploaded', function () {

 7    Storage::fake('avatars');

 8 

 9    $file = UploadedFile::fake()->image('avatar.jpg');

10 

11    $response = $this->post('/avatar', [

12        'avatar' => $file,

13    ]);

14 

15    Storage::disk('avatars')->assertExists($file->hashName());

16});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Illuminate\Http\UploadedFile;

 6use Illuminate\Support\Facades\Storage;

 7use Tests\TestCase;

 8 

 9class ExampleTest extends TestCase

10{

11    public function test_avatars_can_be_uploaded(): void

12    {

13        Storage::fake('avatars');

14 

15        $file = UploadedFile::fake()->image('avatar.jpg');

16 

17        $response = $this->post('/avatar', [

18            'avatar' => $file,

19        ]);

20 

21        Storage::disk('avatars')->assertExists($file->hashName());

22    }

23}

If you would like to assert that a given file does not exist, you may use the assertMissing method provided by the Storage facade:

1Storage::fake('avatars');

2 

3// ...

4 

5Storage::disk('avatars')->assertMissing('missing.jpg');

Fake File Customization

When creating files using the fake method provided by the UploadedFile class, you may specify the width, height, and size of the image (in kilobytes) in order to better test your application's validation rules:

1UploadedFile::fake()->image('avatar.jpg', $width, $height)->size(100);

In addition to creating images, you may create files of any other type using the create method:

1UploadedFile::fake()->create('document.pdf', $sizeInKilobytes);

If needed, you may pass a $mimeType argument to the method to explicitly define the MIME type that should be returned by the file:

1UploadedFile::fake()->create(

2    'document.pdf', $sizeInKilobytes, 'application/pdf'

3);

Testing Views

Laravel also allows you to render a view without making a simulated HTTP request to the application. To accomplish this, you may call the view method within your test. The view method accepts the view name and an optional array of data. The method returns an instance of Illuminate\Testing\TestView, which offers several methods to conveniently make assertions about the view's contents:

1<?php

2 

3test('a welcome view can be rendered', function () {

4    $view = $this->view('welcome', ['name' => 'Taylor']);

5 

6    $view->assertSee('Taylor');

7});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Tests\TestCase;

 6 

 7class ExampleTest extends TestCase

 8{

 9    public function test_a_welcome_view_can_be_rendered(): void

10    {

11        $view = $this->view('welcome', ['name' => 'Taylor']);

12 

13        $view->assertSee('Taylor');

14    }

15}

The TestView class provides the following assertion methods: assertSee, assertSeeInOrder, assertSeeText, assertSeeTextInOrder, assertDontSee, and assertDontSeeText.

If needed, you may get the raw, rendered view contents by casting the TestView instance to a string:

1$contents = (string) $this->view('welcome');

Sharing Errors

Some views may depend on errors shared in the global error bag provided by Laravel. To hydrate the error bag with error messages, you may use the withViewErrors method:

1$view = $this->withViewErrors([

2    'name' => ['Please provide a valid name.']

3])->view('form');

4 

5$view->assertSee('Please provide a valid name.');

Rendering Blade and Components

If necessary, you may use the blade method to evaluate and render a raw Blade string. Like the view method, the blade method returns an instance of Illuminate\Testing\TestView:

1$view = $this->blade(

2    '<x-component :name="$name" />',

3    ['name' => 'Taylor']

4);

5 

6$view->assertSee('Taylor');

You may use the component method to evaluate and render a Blade component. The component method returns an instance of Illuminate\Testing\TestComponent:

1$view = $this->component(Profile::class, ['name' => 'Taylor']);

2 

3$view->assertSee('Taylor');

Caching Routes

Before a test runs, Laravel boots a fresh instance of the application, including collecting all defined routes. If your applications have many route files, you may wish to add the Illuminate\Foundation\Testing\WithCachedRoutes trait to your test cases. On tests which use this trait, routes are built once and stored in memory, meaning the route collection process is only run once for all tests in your suite:

 1<?php

 2 

 3use App\Http\Controllers\UserController;

 4use Illuminate\Foundation\Testing\WithCachedRoutes;

 5 

 6pest()->use(WithCachedRoutes::class);

 7 

 8test('basic example', function () {

 9    $this->get(action([UserController::class, 'index']));

10 

11    // ...

12});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use App\Http\Controllers\UserController;

 6use Illuminate\Foundation\Testing\WithCachedRoutes;

 7use Tests\TestCase;

 8 

 9class BasicTest extends TestCase

10{

11    use WithCachedRoutes;

12 

13    /**

14     * A basic functional test example.

15     */

16    public function test_basic_example(): void

17    {

18        $response = $this->get(action([UserController::class, 'index']));

19 

20        // ...

21    }

22}

Available Assertions
Response Assertions

Laravel's Illuminate\Testing\TestResponse class provides a variety of custom assertion methods that you may utilize when testing your application. These assertions may be accessed on the response that is returned by the json, get, post, put, and delete test methods:
assertAccepted

Assert that the response has an accepted (202) HTTP status code:

1$response->assertAccepted();

assertBadRequest

Assert that the response has a bad request (400) HTTP status code:

1$response->assertBadRequest();

assertClientError

Assert that the response has a client error (>= 400, < 500) HTTP status code:

1$response->assertClientError();

assertConflict

Assert that the response has a conflict (409) HTTP status code:

1$response->assertConflict();

assertCookie

Assert that the response contains the given cookie:

1$response->assertCookie($cookieName, $value = null);

assertCookieExpired

Assert that the response contains the given cookie and it is expired:

1$response->assertCookieExpired($cookieName);

assertCookieNotExpired

Assert that the response contains the given cookie and it is not expired:

1$response->assertCookieNotExpired($cookieName);

assertCookieMissing

Assert that the response does not contain the given cookie:

1$response->assertCookieMissing($cookieName);

assertCreated

Assert that the response has a 201 HTTP status code:

1$response->assertCreated();

assertDontSee

Assert that the given string is not contained within the response returned by the application. This assertion will automatically escape the given string unless you pass a second argument of false:

1$response->assertDontSee($value, $escape = true);

assertDontSeeText

Assert that the given string is not contained within the response text. This assertion will automatically escape the given string unless you pass a second argument of false. This method will pass the response content to the strip_tags PHP function before making the assertion:

1$response->assertDontSeeText($value, $escape = true);

assertDownload

Assert that the response is a "download". Typically, this means the invoked route that returned the response returned a Response::download response, BinaryFileResponse, or Storage::download response:

1$response->assertDownload();

If you wish, you may assert that the downloadable file was assigned a given file name:

1$response->assertDownload('image.jpg');

assertExactJson

Assert that the response contains an exact match of the given JSON data:

1$response->assertExactJson(array $data);

assertExactJsonStructure

Assert that the response contains an exact match of the given JSON structure:

1$response->assertExactJsonStructure(array $data);

This method is a more strict variant of assertJsonStructure. In contrast with assertJsonStructure, this method will fail if the response contains any keys that aren't explicitly included in the expected JSON structure.
assertForbidden

Assert that the response has a forbidden (403) HTTP status code:

1$response->assertForbidden();

assertFound

Assert that the response has a found (302) HTTP status code:

1$response->assertFound();

assertGone

Assert that the response has a gone (410) HTTP status code:

1$response->assertGone();

Assert that the given header and value is present on the response:

1$response->assertHeader($headerName, $value = null);

Assert that the given header contains a given substring value:

1$response->assertHeaderContains($headerName, $value);

Assert that the given header is not present on the response:

1$response->assertHeaderMissing($headerName);

assertInternalServerError

Assert that the response has an "Internal Server Error" (500) HTTP status code:

1$response->assertInternalServerError();

assertJson

Assert that the response contains the given JSON data:

1$response->assertJson(array $data, $strict = false);

The assertJson method converts the response to an array to verify that the given array exists within the JSON response returned by the application. So, if there are other properties in the JSON response, this test will still pass as long as the given fragment is present.
assertJsonCount

Assert that the response JSON has an array with the expected number of items at the given key:

1$response->assertJsonCount($count, $key = null);

assertJsonFragment

Assert that the response contains the given JSON data anywhere in the response:

 1Route::get('/users', function () {

 2    return [

 3        'users' => [

 4            [

 5                'name' => 'Taylor Otwell',

 6            ],

 7        ],

 8    ];

 9});

10 

11$response->assertJsonFragment(['name' => 'Taylor Otwell']);

assertJsonIsArray

Assert that the response JSON is an array:

1$response->assertJsonIsArray();

assertJsonIsObject

Assert that the response JSON is an object:

1$response->assertJsonIsObject();

assertJsonMissing

Assert that the response does not contain the given JSON data:

1$response->assertJsonMissing(array $data);

assertJsonMissingExact

Assert that the response does not contain the exact JSON data:

1$response->assertJsonMissingExact(array $data);

assertJsonMissingValidationErrors

Assert that the response has no JSON validation errors for the given keys:

1$response->assertJsonMissingValidationErrors($keys);

The more generic assertValid method may be used to assert that a response does not have validation errors that were returned as JSON and that no errors were flashed to session storage.
assertJsonPath

Assert that the response contains the given data at the specified path:

1$response->assertJsonPath($path, $expectedValue);

For example, if the following JSON response is returned by your application:

1{

2    "user": {

3        "name": "Steve Schoger"

4    }

5}

You may assert that the name property of the user object matches a given value like so:

1$response->assertJsonPath('user.name', 'Steve Schoger');

assertJsonMissingPath

Assert that the response does not contain the given path:

1$response->assertJsonMissingPath($path);

For example, if the following JSON response is returned by your application:

1{

2    "user": {

3        "name": "Steve Schoger"

4    }

5}

You may assert that it does not contain the email property of the user object:

1$response->assertJsonMissingPath('user.email');

assertJsonStructure

Assert that the response has a given JSON structure:

1$response->assertJsonStructure(array $structure);

For example, if the JSON response returned by your application contains the following data:

1{

2    "user": {

3        "name": "Steve Schoger"

4    }

5}

You may assert that the JSON structure matches your expectations like so:

1$response->assertJsonStructure([

2    'user' => [

3        'name',

4    ]

5]);

Sometimes, JSON responses returned by your application may contain arrays of objects:

 1{

 2    "user": [

 3        {

 4            "name": "Steve Schoger",

 5            "age": 55,

 6            "location": "Earth"

 7        },

 8        {

 9            "name": "Mary Schoger",

10            "age": 60,

11            "location": "Earth"

12        }

13    ]

14}

In this situation, you may use the * character to assert against the structure of all of the objects in the array:

1$response->assertJsonStructure([

2    'user' => [

3        '*' => [

4             'name',

5             'age',

6             'location'

7        ]

8    ]

9]);

assertJsonValidationErrors

Assert that the response has the given JSON validation errors for the given keys. This method should be used when asserting against responses where the validation errors are returned as a JSON structure instead of being flashed to the session:

1$response->assertJsonValidationErrors(array $data, $responseKey = 'errors');

The more generic assertInvalid method may be used to assert that a response has validation errors returned as JSON or that errors were flashed to session storage.
assertJsonValidationErrorFor

Assert the response has any JSON validation errors for the given key:

1$response->assertJsonValidationErrorFor(string $key, $responseKey = 'errors');

assertMethodNotAllowed

Assert that the response has a method not allowed (405) HTTP status code:

1$response->assertMethodNotAllowed();

assertMovedPermanently

Assert that the response has a moved permanently (301) HTTP status code:

1$response->assertMovedPermanently();

assertLocation

Assert that the response has the given URI value in the Location header:

1$response->assertLocation($uri);

assertContent

Assert that the given string matches the response content:

1$response->assertContent($value);

assertNoContent

Assert that the response has the given HTTP status code and no content:

1$response->assertNoContent($status = 204);

assertStreamed

Assert that the response was a streamed response:

1$response->assertStreamed();

assertStreamedContent

Assert that the given string matches the streamed response content:

1$response->assertStreamedContent($value);

assertNotFound

Assert that the response has a not found (404) HTTP status code:

1$response->assertNotFound();

assertOk

Assert that the response has a 200 HTTP status code:

1$response->assertOk();

assertPaymentRequired

Assert that the response has a payment required (402) HTTP status code:

1$response->assertPaymentRequired();

assertPlainCookie

Assert that the response contains the given unencrypted cookie:

1$response->assertPlainCookie($cookieName, $value = null);

assertRedirect

Assert that the response is a redirect to the given URI:

1$response->assertRedirect($uri = null);

assertRedirectBack

Assert whether the response is redirecting back to the previous page:

1$response->assertRedirectBack();

assertRedirectBackWithErrors

Assert whether the response is redirecting back to the previous page and the session has the given errors:

1$response->assertRedirectBackWithErrors(

2    array $keys = [], $format = null, $errorBag = 'default'

3);

assertRedirectBackWithoutErrors

Assert whether the response is redirecting back to the previous page and the session does not contain any error messages:

1$response->assertRedirectBackWithoutErrors();

assertRedirectContains

Assert whether the response is redirecting to a URI that contains the given string:

1$response->assertRedirectContains($string);

assertRedirectToRoute

Assert that the response is a redirect to the given named route:

1$response->assertRedirectToRoute($name, $parameters = []);

assertRedirectToSignedRoute

Assert that the response is a redirect to the given signed route:

1$response->assertRedirectToSignedRoute($name = null, $parameters = []);

assertRequestTimeout

Assert that the response has a request timeout (408) HTTP status code:

1$response->assertRequestTimeout();

assertSee

Assert that the given string is contained within the response. This assertion will automatically escape the given string unless you pass a second argument of false:

1$response->assertSee($value, $escape = true);

assertSeeInOrder

Assert that the given strings are contained in order within the response. This assertion will automatically escape the given strings unless you pass a second argument of false:

1$response->assertSeeInOrder(array $values, $escape = true);

assertSeeText

Assert that the given string is contained within the response text. This assertion will automatically escape the given string unless you pass a second argument of false. The response content will be passed to the strip_tags PHP function before the assertion is made:

1$response->assertSeeText($value, $escape = true);

assertSeeTextInOrder

Assert that the given strings are contained in order within the response text. This assertion will automatically escape the given strings unless you pass a second argument of false. The response content will be passed to the strip_tags PHP function before the assertion is made:

1$response->assertSeeTextInOrder(array $values, $escape = true);

assertServerError

Assert that the response has a server error (>= 500 , < 600) HTTP status code:

1$response->assertServerError();

assertServiceUnavailable

Assert that the response has a "Service Unavailable" (503) HTTP status code:

1$response->assertServiceUnavailable();

assertSessionHas

Assert that the session contains the given piece of data:

1$response->assertSessionHas($key, $value = null);

If needed, a closure can be provided as the second argument to the assertSessionHas method. The assertion will pass if the closure returns true:

1$response->assertSessionHas($key, function (User $value) {

2    return $value->name === 'Taylor Otwell';

3});

assertSessionHasInput

Assert that the session has a given value in the flashed input array:

1$response->assertSessionHasInput($key, $value = null);

If needed, a closure can be provided as the second argument to the assertSessionHasInput method. The assertion will pass if the closure returns true:

1use Illuminate\Support\Facades\Crypt;

2 

3$response->assertSessionHasInput($key, function (string $value) {

4    return Crypt::decryptString($value) === 'secret';

5});

assertSessionHasAll

Assert that the session contains a given array of key / value pairs:

1$response->assertSessionHasAll(array $data);

For example, if your application's session contains name and status keys, you may assert that both exist and have the specified values like so:

1$response->assertSessionHasAll([

2    'name' => 'Taylor Otwell',

3    'status' => 'active',

4]);

assertSessionHasErrors

Assert that the session contains an error for the given $keys. If $keys is an associative array, assert that the session contains a specific error message (value) for each field (key). This method should be used when testing routes that flash validation errors to the session instead of returning them as a JSON structure:

1$response->assertSessionHasErrors(

2    array $keys = [], $format = null, $errorBag = 'default'

3);

For example, to assert that the name and email fields have validation error messages that were flashed to the session, you may invoke the assertSessionHasErrors method like so:

1$response->assertSessionHasErrors(['name', 'email']);

Or, you may assert that a given field has a particular validation error message:

1$response->assertSessionHasErrors([

2    'name' => 'The given name was invalid.'

3]);

The more generic assertInvalid method may be used to assert that a response has validation errors returned as JSON or that errors were flashed to session storage.
assertSessionHasErrorsIn

Assert that the session contains an error for the given $keys within a specific error bag. If $keys is an associative array, assert that the session contains a specific error message (value) for each field (key), within the error bag:

1$response->assertSessionHasErrorsIn($errorBag, $keys = [], $format = null);

assertSessionHasNoErrors

Assert that the session has no validation errors:

1$response->assertSessionHasNoErrors();

assertSessionDoesntHaveErrors

Assert that the session has no validation errors for the given keys:

1$response->assertSessionDoesntHaveErrors($keys = [], $format = null, $errorBag = 'default');

The more generic assertValid method may be used to assert that a response does not have validation errors that were returned as JSON and that no errors were flashed to session storage.
assertSessionMissing

Assert that the session does not contain the given key:

1$response->assertSessionMissing($key);

assertStatus

Assert that the response has a given HTTP status code:

1$response->assertStatus($code);

assertSuccessful

Assert that the response has a successful (>= 200 and < 300) HTTP status code:

1$response->assertSuccessful();

assertTooManyRequests

Assert that the response has a too many requests (429) HTTP status code:

1$response->assertTooManyRequests();

Assert that the response has an unauthorized (401) HTTP status code:

1$response->assertUnauthorized();

assertUnprocessable

Assert that the response has an unprocessable entity (422) HTTP status code:

1$response->assertUnprocessable();

assertUnsupportedMediaType

Assert that the response has an unsupported media type (415) HTTP status code:

1$response->assertUnsupportedMediaType();

assertValid

Assert that the response has no validation errors for the given keys. This method may be used for asserting against responses where the validation errors are returned as a JSON structure or where the validation errors have been flashed to the session:

1// Assert that no validation errors are present...

2$response->assertValid();

3 

4// Assert that the given keys do not have validation errors...

5$response->assertValid(['name', 'email']);

assertInvalid

Assert that the response has validation errors for the given keys. This method may be used for asserting against responses where the validation errors are returned as a JSON structure or where the validation errors have been flashed to the session:

1$response->assertInvalid(['name', 'email']);

You may also assert that a given key has a particular validation error message. When doing so, you may provide the entire message or only a small portion of the message:

1$response->assertInvalid([

2    'name' => 'The name field is required.',

3    'email' => 'valid email address',

4]);

If you would like to assert that the given fields are the only fields with validation errors, you may use the assertOnlyInvalid method:

1$response->assertOnlyInvalid(['name', 'email']);

assertViewHas

Assert that the response view contains a given piece of data:

1$response->assertViewHas($key, $value = null);

Passing a closure as the second argument to the assertViewHas method will allow you to inspect and make assertions against a particular piece of view data:

1$response->assertViewHas('user', function (User $user) {

2    return $user->name === 'Taylor';

3});

In addition, view data may be accessed as array variables on the response, allowing you to conveniently inspect it:

1expect($response['name'])->toBe('Taylor');

1$this->assertEquals('Taylor', $response['name']);

assertViewHasAll

Assert that the response view has a given list of data:

1$response->assertViewHasAll(array $data);

This method may be used to assert that the view simply contains data matching the given keys:

1$response->assertViewHasAll([

2    'name',

3    'email',

4]);

Or, you may assert that the view data is present and has specific values:

1$response->assertViewHasAll([

2    'name' => 'Taylor Otwell',

3    'email' => 'taylor@example.com,',

4]);

assertViewIs

Assert that the given view was returned by the route:

1$response->assertViewIs($value);

assertViewMissing

Assert that the given data key was not made available to the view returned in the application's response:

1$response->assertViewMissing($key);

Authentication Assertions

Laravel also provides a variety of authentication related assertions that you may utilize within your application's feature tests. Note that these methods are invoked on the test class itself and not the Illuminate\Testing\TestResponse instance returned by methods such as get and post.
assertAuthenticated

Assert that a user is authenticated:

1$this->assertAuthenticated($guard = null);

assertGuest

Assert that a user is not authenticated:

1$this->assertGuest($guard = null);

assertAuthenticatedAs

Assert that a specific user is authenticated:

1$this->assertAuthenticatedAs($user, $guard = null);

Validation Assertions

Laravel provides two primary validation related assertions that you may use to ensure the data provided in your request was either valid or invalid.
assertValid

Assert that the response has no validation errors for the given keys. This method may be used for asserting against responses where the validation errors are returned as a JSON structure or where the validation errors have been flashed to the session:

1// Assert that no validation errors are present...

2$response->assertValid();

3 

4// Assert that the given keys do not have validation errors...

5$response->assertValid(['name', 'email']);

assertInvalid

Assert that the response has validation errors for the given keys. This method may be used for asserting against responses where the validation errors are returned as a JSON structure or where the validation errors have been flashed to the session:

1$response->assertInvalid(['name', 'email']);

You may also assert that a given key has a particular validation error message. When doing so, you may provide the entire message or only a small portion of the message:

1$response->assertInvalid([

2    'name' => 'The name field is required.',

3    'email' => 'valid email address',

4]);



laravel.com
Console Tests - Laravel 12.x - The PHP Framework For Web Artisans
6–7 minutes

    Introduction
    Success / Failure Expectations
    Input / Output Expectations
    Console Events

Introduction

In addition to simplifying HTTP testing, Laravel provides a simple API for testing your application's custom console commands.
Success / Failure Expectations

To get started, let's explore how to make assertions regarding an Artisan command's exit code. To accomplish this, we will use the artisan method to invoke an Artisan command from our test. Then, we will use the assertExitCode method to assert that the command completed with a given exit code:

1test('console command', function () {

2    $this->artisan('inspire')->assertExitCode(0);

3});

1/**

2 * Test a console command.

3 */

4public function test_console_command(): void

5{

6    $this->artisan('inspire')->assertExitCode(0);

7}

You may use the assertNotExitCode method to assert that the command did not exit with a given exit code:

1$this->artisan('inspire')->assertNotExitCode(1);

Of course, all terminal commands typically exit with a status code of 0 when they are successful and a non-zero exit code when they are not successful. Therefore, for convenience, you may utilize the assertSuccessful and assertFailed assertions to assert that a given command exited with a successful exit code or not:

1$this->artisan('inspire')->assertSuccessful();

2 

3$this->artisan('inspire')->assertFailed();

Input / Output Expectations

Laravel allows you to easily "mock" user input for your console commands using the expectsQuestion method. In addition, you may specify the exit code and text that you expect to be output by the console command using the assertExitCode and expectsOutput methods. For example, consider the following console command:

 1Artisan::command('question', function () {

 2    $name = $this->ask('What is your name?');

 3 

 4    $language = $this->choice('Which language do you prefer?', [

 5        'PHP',

 6        'Ruby',

 7        'Python',

 8    ]);

 9 

10    $this->line('Your name is '.$name.' and you prefer '.$language.'.');

11});

You may test this command with the following test:

1test('console command', function () {

2    $this->artisan('question')

3        ->expectsQuestion('What is your name?', 'Taylor Otwell')

4        ->expectsQuestion('Which language do you prefer?', 'PHP')

5        ->expectsOutput('Your name is Taylor Otwell and you prefer PHP.')

6        ->doesntExpectOutput('Your name is Taylor Otwell and you prefer Ruby.')

7        ->assertExitCode(0);

8});

 1/**

 2 * Test a console command.

 3 */

 4public function test_console_command(): void

 5{

 6    $this->artisan('question')

 7        ->expectsQuestion('What is your name?', 'Taylor Otwell')

 8        ->expectsQuestion('Which language do you prefer?', 'PHP')

 9        ->expectsOutput('Your name is Taylor Otwell and you prefer PHP.')

10        ->doesntExpectOutput('Your name is Taylor Otwell and you prefer Ruby.')

11        ->assertExitCode(0);

12}

If you are utilizing the search or multisearch functions provided by Laravel Prompts, you may use the expectsSearch assertion to mock the user's input, search results, and selection:

1test('console command', function () {

2    $this->artisan('example')

3        ->expectsSearch('What is your name?', search: 'Tay', answers: [

4            'Taylor Otwell',

5            'Taylor Swift',

6            'Darian Taylor'

7        ], answer: 'Taylor Otwell')

8        ->assertExitCode(0);

9});

 1/**

 2 * Test a console command.

 3 */

 4public function test_console_command(): void

 5{

 6    $this->artisan('example')

 7        ->expectsSearch('What is your name?', search: 'Tay', answers: [

 8            'Taylor Otwell',

 9            'Taylor Swift',

10            'Darian Taylor'

11        ], answer: 'Taylor Otwell')

12        ->assertExitCode(0);

13}

You may also assert that a console command does not generate any output using the doesntExpectOutput method:

1test('console command', function () {

2    $this->artisan('example')

3        ->doesntExpectOutput()

4        ->assertExitCode(0);

5});

1/**

2 * Test a console command.

3 */

4public function test_console_command(): void

5{

6    $this->artisan('example')

7        ->doesntExpectOutput()

8        ->assertExitCode(0);

9}

The expectsOutputToContain and doesntExpectOutputToContain methods may be used to make assertions against a portion of the output:

1test('console command', function () {

2    $this->artisan('example')

3        ->expectsOutputToContain('Taylor')

4        ->assertExitCode(0);

5});

1/**

2 * Test a console command.

3 */

4public function test_console_command(): void

5{

6    $this->artisan('example')

7        ->expectsOutputToContain('Taylor')

8        ->assertExitCode(0);

9}

Confirmation Expectations

When writing a command which expects confirmation in the form of a "yes" or "no" answer, you may utilize the expectsConfirmation method:

1$this->artisan('module:import')

2    ->expectsConfirmation('Do you really wish to run this command?', 'no')

3    ->assertExitCode(1);

Table Expectations

If your command displays a table of information using Artisan's table method, it can be cumbersome to write output expectations for the entire table. Instead, you may use the expectsTable method. This method accepts the table's headers as its first argument and the table's data as its second argument:

1$this->artisan('users:all')

2    ->expectsTable([

3        'ID',

4        'Email',

5    ], [

6        [1, 'taylor@example.com'],

7        [2, 'abigail@example.com'],

8    ]);

Console Events

By default, the Illuminate\Console\Events\CommandStarting and Illuminate\Console\Events\CommandFinished events are not dispatched while running your application's tests. However, you can enable these events for a given test class by adding the Illuminate\Foundation\Testing\WithConsoleEvents trait to the class:

1<?php

2 

3use Illuminate\Foundation\Testing\WithConsoleEvents;

4 

5pest()->use(WithConsoleEvents::class);

6 

7// ...

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Illuminate\Foundation\Testing\WithConsoleEvents;

 6use Tests\TestCase;

 7 

 8class ConsoleEventTest extends TestCase

 9{

10    use WithConsoleEvents;

11 

12    // ...

13}


laravel.com
Database Testing - Laravel 12.x - The PHP Framework For Web Artisans
7–9 minutes
Database Testing

    Introduction
        Resetting the Database After Each Test
    Model Factories
    Running Seeders
    Available Assertions

Introduction

Laravel provides a variety of helpful tools and assertions to make it easier to test your database driven applications. In addition, Laravel model factories and seeders make it painless to create test database records using your application's Eloquent models and relationships. We'll discuss all of these powerful features in the following documentation.
Resetting the Database After Each Test

Before proceeding much further, let's discuss how to reset your database after each of your tests so that data from a previous test does not interfere with subsequent tests. Laravel's included Illuminate\Foundation\Testing\RefreshDatabase trait will take care of this for you. Simply use the trait on your test class:

 1<?php

 2 

 3use Illuminate\Foundation\Testing\RefreshDatabase;

 4 

 5pest()->use(RefreshDatabase::class);

 6 

 7test('basic example', function () {

 8    $response = $this->get('/');

 9 

10    // ...

11});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Illuminate\Foundation\Testing\RefreshDatabase;

 6use Tests\TestCase;

 7 

 8class ExampleTest extends TestCase

 9{

10    use RefreshDatabase;

11 

12    /**

13     * A basic functional test example.

14     */

15    public function test_basic_example(): void

16    {

17        $response = $this->get('/');

18 

19        // ...

20    }

21}

The Illuminate\Foundation\Testing\RefreshDatabase trait does not migrate your database if your schema is up to date. Instead, it will only execute the test within a database transaction. Therefore, any records added to the database by test cases that do not use this trait may still exist in the database.

If you would like to totally reset the database, you may use the Illuminate\Foundation\Testing\DatabaseMigrations or Illuminate\Foundation\Testing\DatabaseTruncation traits instead. However, both of these options are significantly slower than the RefreshDatabase trait.
Model Factories

When testing, you may need to insert a few records into your database before executing your test. Instead of manually specifying the value of each column when you create this test data, Laravel allows you to define a set of default attributes for each of your Eloquent models using model factories.

To learn more about creating and utilizing model factories to create models, please consult the complete model factory documentation. Once you have defined a model factory, you may utilize the factory within your test to create models:

1use App\Models\User;

2 

3test('models can be instantiated', function () {

4    $user = User::factory()->create();

5 

6    // ...

7});

1use App\Models\User;

2 

3public function test_models_can_be_instantiated(): void

4{

5    $user = User::factory()->create();

6 

7    // ...

8}

Running Seeders

If you would like to use database seeders to populate your database during a feature test, you may invoke the seed method. By default, the seed method will execute the DatabaseSeeder, which should execute all of your other seeders. Alternatively, you pass a specific seeder class name to the seed method:

 1<?php

 2 

 3use Database\Seeders\OrderStatusSeeder;

 4use Database\Seeders\TransactionStatusSeeder;

 5use Illuminate\Foundation\Testing\RefreshDatabase;

 6 

 7pest()->use(RefreshDatabase::class);

 8 

 9test('orders can be created', function () {

10    // Run the DatabaseSeeder...

11    $this->seed();

12 

13    // Run a specific seeder...

14    $this->seed(OrderStatusSeeder::class);

15 

16    // ...

17 

18    // Run an array of specific seeders...

19    $this->seed([

20        OrderStatusSeeder::class,

21        TransactionStatusSeeder::class,

22        // ...

23    ]);

24});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Database\Seeders\OrderStatusSeeder;

 6use Database\Seeders\TransactionStatusSeeder;

 7use Illuminate\Foundation\Testing\RefreshDatabase;

 8use Tests\TestCase;

 9 

10class ExampleTest extends TestCase

11{

12    use RefreshDatabase;

13 

14    /**

15     * Test creating a new order.

16     */

17    public function test_orders_can_be_created(): void

18    {

19        // Run the DatabaseSeeder...

20        $this->seed();

21 

22        // Run a specific seeder...

23        $this->seed(OrderStatusSeeder::class);

24 

25        // ...

26 

27        // Run an array of specific seeders...

28        $this->seed([

29            OrderStatusSeeder::class,

30            TransactionStatusSeeder::class,

31            // ...

32        ]);

33    }

34}

Alternatively, you may instruct Laravel to automatically seed the database before each test that uses the RefreshDatabase trait. You may accomplish this by defining a $seed property on your base test class:

 1<?php

 2 

 3namespace Tests;

 4 

 5use Illuminate\Foundation\Testing\TestCase as BaseTestCase;

 6 

 7abstract class TestCase extends BaseTestCase

 8{

 9    /**

10     * Indicates whether the default seeder should run before each test.

11     *

12     * @var bool

13     */

14    protected $seed = true;

15}

When the $seed property is true, the test will run the Database\Seeders\DatabaseSeeder class before each test that uses the RefreshDatabase trait. However, you may specify a specific seeder that should be executed by defining a $seeder property on your test class:

1use Database\Seeders\OrderStatusSeeder;

2 

3/**

4 * Run a specific seeder before each test.

5 *

6 * @var string

7 */

8protected $seeder = OrderStatusSeeder::class;

Available Assertions

Laravel provides several database assertions for your Pest or PHPUnit feature tests. We'll discuss each of these assertions below.
assertDatabaseCount

Assert that a table in the database contains the given number of records:

1$this->assertDatabaseCount('users', 5);

assertDatabaseEmpty

Assert that a table in the database contains no records:

1$this->assertDatabaseEmpty('users');

assertDatabaseHas

Assert that a table in the database contains records matching the given key / value query constraints:

1$this->assertDatabaseHas('users', [

2    'email' => 'sally@example.com',

3]);

assertDatabaseMissing

Assert that a table in the database does not contain records matching the given key / value query constraints:

1$this->assertDatabaseMissing('users', [

2    'email' => 'sally@example.com',

3]);

assertSoftDeleted

The assertSoftDeleted method may be used to assert a given Eloquent model has been "soft deleted":

1$this->assertSoftDeleted($user);

assertNotSoftDeleted

The assertNotSoftDeleted method may be used to assert a given Eloquent model hasn't been "soft deleted":

1$this->assertNotSoftDeleted($user);

assertModelExists

Assert that a given model or collection of models exist in the database:

1use App\Models\User;

2 

3$user = User::factory()->create();

4 

5$this->assertModelExists($user);

assertModelMissing

Assert that a given model or collection of models do not exist in the database:

1use App\Models\User;

2 

3$user = User::factory()->create();

4 

5$user->delete();

6 

7$this->assertModelMissing($user);

expectsDatabaseQueryCount

The expectsDatabaseQueryCount method may be invoked at the beginning of your test to specify the total number of database queries that you expect to be run during the test. If the actual number of executed queries does not exactly match this expectation, the test will fail:

1$this->expectsDatabaseQueryCount(5);

2 

3// Test...


laravel.com
Mocking - Laravel 12.x - The PHP Framework For Web Artisans
8–10 minutes

    Introduction
    Mocking Objects
    Mocking Facades
        Facade Spies
    Interacting With Time

Introduction

When testing Laravel applications, you may wish to "mock" certain aspects of your application so they are not actually executed during a given test. For example, when testing a controller that dispatches an event, you may wish to mock the event listeners so they are not actually executed during the test. This allows you to only test the controller's HTTP response without worrying about the execution of the event listeners since the event listeners can be tested in their own test case.

Laravel provides helpful methods for mocking events, jobs, and other facades out of the box. These helpers primarily provide a convenience layer over Mockery so you do not have to manually make complicated Mockery method calls.
Mocking Objects

When mocking an object that is going to be injected into your application via Laravel's service container, you will need to bind your mocked instance into the container as an instance binding. This will instruct the container to use your mocked instance of the object instead of constructing the object itself:

 1use App\Service;

 2use Mockery;

 3use Mockery\MockInterface;

 4 

 5test('something can be mocked', function () {

 6    $this->instance(

 7        Service::class,

 8        Mockery::mock(Service::class, function (MockInterface $mock) {

 9            $mock->expects('process');

10        })

11    );

12});

 1use App\Service;

 2use Mockery;

 3use Mockery\MockInterface;

 4 

 5public function test_something_can_be_mocked(): void

 6{

 7    $this->instance(

 8        Service::class,

 9        Mockery::mock(Service::class, function (MockInterface $mock) {

10            $mock->expects('process');

11        })

12    );

13}

In order to make this more convenient, you may use the mock method that is provided by Laravel's base test case class. For example, the following example is equivalent to the example above:

1use App\Service;

2use Mockery\MockInterface;

3 

4$mock = $this->mock(Service::class, function (MockInterface $mock) {

5    $mock->expects('process');

6});

You may use the partialMock method when you only need to mock a few methods of an object. The methods that are not mocked will be executed normally when called:

1use App\Service;

2use Mockery\MockInterface;

3 

4$mock = $this->partialMock(Service::class, function (MockInterface $mock) {

5    $mock->expects('process');

6});

Similarly, if you want to spy on an object, Laravel's base test case class offers a spy method as a convenient wrapper around the Mockery::spy method. Spies are similar to mocks; however, spies record any interaction between the spy and the code being tested, allowing you to make assertions after the code is executed:

1use App\Service;

2 

3$spy = $this->spy(Service::class);

4 

5// ...

6 

7$spy->shouldHaveReceived('process');

Mocking Facades

Unlike traditional static method calls, facades (including real-time facades) may be mocked. This provides a great advantage over traditional static methods and grants you the same testability that you would have if you were using traditional dependency injection. When testing, you may often want to mock a call to a Laravel facade that occurs in one of your controllers. For example, consider the following controller action:

 1<?php

 2 

 3namespace App\Http\Controllers;

 4 

 5use Illuminate\Support\Facades\Cache;

 6 

 7class UserController extends Controller

 8{

 9    /**

10     * Retrieve a list of all users of the application.

11     */

12    public function index(): array

13    {

14        $value = Cache::get('key');

15 

16        return [

17            // ...

18        ];

19    }

20}

We can mock the call to the Cache facade by using the expects method, which will return an instance of a Mockery mock. Since facades are actually resolved and managed by the Laravel service container, they have much more testability than a typical static class. For example, let's mock our call to the Cache facade's get method:

 1<?php

 2 

 3use Illuminate\Support\Facades\Cache;

 4 

 5test('get index', function () {

 6    Cache::expects('get')

 7        ->with('key')

 8        ->andReturn('value');

 9 

10    $response = $this->get('/users');

11 

12    // ...

13});

 1<?php

 2 

 3namespace Tests\Feature;

 4 

 5use Illuminate\Support\Facades\Cache;

 6use Tests\TestCase;

 7 

 8class UserControllerTest extends TestCase

 9{

10    public function test_get_index(): void

11    {

12        Cache::expects('get')

13            ->with('key')

14            ->andReturn('value');

15 

16        $response = $this->get('/users');

17 

18        // ...

19    }

20}

You should not mock the Request facade. Instead, pass the input you desire into the HTTP testing methods such as get and post when running your test. Likewise, instead of mocking the Config facade, call the Config::set method in your tests.
Facade Spies

If you would like to spy on a facade, you may call the spy method on the corresponding facade. Spies are similar to mocks; however, spies record any interaction between the spy and the code being tested, allowing you to make assertions after the code is executed:

 1<?php

 2 

 3use Illuminate\Support\Facades\Cache;

 4 

 5test('values are stored in cache', function () {

 6    Cache::spy();

 7 

 8    $response = $this->get('/');

 9 

10    $response->assertStatus(200);

11 

12    Cache::shouldHaveReceived('put')->with('name', 'Taylor', 10);

13});

 1use Illuminate\Support\Facades\Cache;

 2 

 3public function test_values_are_stored_in_cache(): void

 4{

 5    Cache::spy();

 6 

 7    $response = $this->get('/');

 8 

 9    $response->assertStatus(200);

10 

11    Cache::shouldHaveReceived('put')->with('name', 'Taylor', 10);

12}

Interacting With Time

When testing, you may occasionally need to modify the time returned by helpers such as now or Illuminate\Support\Carbon::now(). Thankfully, Laravel's base feature test class includes helpers that allow you to manipulate the current time:

 1test('time can be manipulated', function () {

 2    // Travel into the future...

 3    $this->travel(5)->milliseconds();

 4    $this->travel(5)->seconds();

 5    $this->travel(5)->minutes();

 6    $this->travel(5)->hours();

 7    $this->travel(5)->days();

 8    $this->travel(5)->weeks();

 9    $this->travel(5)->years();

10 

11    // Travel into the past...

12    $this->travel(-5)->hours();

13 

14    // Travel to an explicit time...

15    $this->travelTo(now()->minus(hours: 6));

16 

17    // Return back to the present time...

18    $this->travelBack();

19});

 1public function test_time_can_be_manipulated(): void

 2{

 3    // Travel into the future...

 4    $this->travel(5)->milliseconds();

 5    $this->travel(5)->seconds();

 6    $this->travel(5)->minutes();

 7    $this->travel(5)->hours();

 8    $this->travel(5)->days();

 9    $this->travel(5)->weeks();

10    $this->travel(5)->years();

11 

12    // Travel into the past...

13    $this->travel(-5)->hours();

14 

15    // Travel to an explicit time...

16    $this->travelTo(now()->minus(hours: 6));

17 

18    // Return back to the present time...

19    $this->travelBack();

20}

You may also provide a closure to the various time travel methods. The closure will be invoked with time frozen at the specified time. Once the closure has executed, time will resume as normal:

1$this->travel(5)->days(function () {

2    // Test something five days into the future...

3});

4 

5$this->travelTo(now()->mins(days: 10), function () {

6    // Test something during a given moment...

7});

The freezeTime method may be used to freeze the current time. Similarly, the freezeSecond method will freeze the current time but at the start of the current second:

 1use Illuminate\Support\Carbon;

 2 

 3// Freeze time and resume normal time after executing closure...

 4$this->freezeTime(function (Carbon $time) {

 5    // ...

 6});

 7 

 8// Freeze time at the current second and resume normal time after executing closure...

 9$this->freezeSecond(function (Carbon $time) {

10    // ...

11})

As you would expect, all of the methods discussed above are primarily useful for testing time sensitive application behavior, such as locking inactive posts on a discussion forum:

1use App\Models\Thread;

2 

3test('forum threads lock after one week of inactivity', function () {

4    $thread = Thread::factory()->create();

5 

6    $this->travel(1)->week();

7 

8    expect($thread->isLockedByInactivity())->toBeTrue();

9});

 1use App\Models\Thread;

 2 

 3public function test_forum_threads_lock_after_one_week_of_inactivity()

 4{

 5    $thread = Thread::factory()->create();

 6 

 7    $this->travel(1)->week();

 8 

 9    $this->assertTrue($thread->isLockedByInactivity());

10}


